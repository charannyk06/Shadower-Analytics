"""Vulnerability scanning utilities for security assessment."""

import subprocess
import json
import logging
from typing import Dict, Any, List, Optional
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)


class SecurityScanner:
    """
    Comprehensive security scanner for vulnerability assessment.

    Integrates with multiple security scanning tools.
    """

    def __init__(self, project_root: Optional[str] = None):
        """
        Initialize security scanner.

        Args:
            project_root: Root directory of the project to scan
        """
        self.project_root = project_root or str(Path(__file__).parent.parent.parent)
        self.scanners = {
            "dependencies": self._scan_dependencies,
            "code": self._scan_code,
            "secrets": self._scan_secrets,
        }

    async def run_security_scan(
        self, scan_types: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        Run comprehensive security scan.

        Args:
            scan_types: List of scan types to run (None = all)

        Returns:
            Dictionary with scan results
        """
        results = {
            "timestamp": datetime.utcnow().isoformat(),
            "project_root": self.project_root,
            "scans": {},
            "summary": {
                "total_vulnerabilities": 0,
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
            },
        }

        # Determine which scans to run
        scans_to_run = scan_types or list(self.scanners.keys())

        for scan_type in scans_to_run:
            if scan_type not in self.scanners:
                logger.warning(f"Unknown scan type: {scan_type}")
                continue

            try:
                logger.info(f"Running {scan_type} scan...")
                scan_result = await self.scanners[scan_type]()
                results["scans"][scan_type] = scan_result

                # Update summary
                if "vulnerabilities" in scan_result:
                    results["summary"]["total_vulnerabilities"] += len(
                        scan_result["vulnerabilities"]
                    )

            except Exception as e:
                logger.error(f"Failed to run {scan_type} scan: {e}")
                results["scans"][scan_type] = {
                    "error": str(e),
                    "status": "failed",
                }

        return results

    async def _scan_dependencies(self) -> Dict[str, Any]:
        """
        Scan Python dependencies for known vulnerabilities.

        Uses safety (https://github.com/pyupio/safety)

        Returns:
            Dictionary with vulnerability findings
        """
        try:
            # Run safety check
            result = subprocess.run(
                ["safety", "check", "--json"],
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=60,
            )

            if result.returncode == 0 and result.stdout:
                vulnerabilities = json.loads(result.stdout)
            else:
                vulnerabilities = []

            return {
                "status": "completed",
                "tool": "safety",
                "vulnerabilities": vulnerabilities,
                "count": len(vulnerabilities),
            }

        except FileNotFoundError:
            logger.warning("safety tool not found. Install with: pip install safety")
            return {
                "status": "skipped",
                "reason": "safety tool not installed",
            }
        except subprocess.TimeoutExpired:
            logger.error("Dependency scan timed out")
            return {
                "status": "timeout",
                "reason": "Scan exceeded 60 second timeout",
            }
        except Exception as e:
            logger.error(f"Dependency scan failed: {e}")
            return {
                "status": "error",
                "error": str(e),
            }

    async def _scan_code(self) -> Dict[str, Any]:
        """
        Scan code for security issues.

        Uses bandit (https://github.com/PyCQA/bandit)

        Returns:
            Dictionary with security issue findings
        """
        try:
            # Run bandit scan
            result = subprocess.run(
                ["bandit", "-r", ".", "-f", "json", "--skip", "B101"],
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=120,
            )

            if result.stdout:
                scan_data = json.loads(result.stdout)
                issues = scan_data.get("results", [])
            else:
                issues = []

            # Categorize by severity
            severity_counts = {"HIGH": 0, "MEDIUM": 0, "LOW": 0}
            for issue in issues:
                severity = issue.get("issue_severity", "UNKNOWN")
                if severity in severity_counts:
                    severity_counts[severity] += 1

            return {
                "status": "completed",
                "tool": "bandit",
                "issues": issues,
                "count": len(issues),
                "severity_breakdown": severity_counts,
            }

        except FileNotFoundError:
            logger.warning("bandit tool not found. Install with: pip install bandit")
            return {
                "status": "skipped",
                "reason": "bandit tool not installed",
            }
        except subprocess.TimeoutExpired:
            logger.error("Code scan timed out")
            return {
                "status": "timeout",
                "reason": "Scan exceeded 120 second timeout",
            }
        except Exception as e:
            logger.error(f"Code scan failed: {e}")
            return {
                "status": "error",
                "error": str(e),
            }

    async def _scan_secrets(self) -> Dict[str, Any]:
        """
        Scan for hardcoded secrets and credentials.

        Uses detect-secrets (https://github.com/Yelp/detect-secrets)

        Returns:
            Dictionary with secret findings
        """
        try:
            # Run detect-secrets scan
            result = subprocess.run(
                ["detect-secrets", "scan", "--all-files"],
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=60,
            )

            if result.stdout:
                scan_data = json.loads(result.stdout)
                secrets = scan_data.get("results", {})

                # Count total secrets found
                total_secrets = sum(len(files) for files in secrets.values())
            else:
                secrets = {}
                total_secrets = 0

            return {
                "status": "completed",
                "tool": "detect-secrets",
                "findings": secrets,
                "count": total_secrets,
            }

        except FileNotFoundError:
            logger.warning(
                "detect-secrets tool not found. "
                "Install with: pip install detect-secrets"
            )
            return {
                "status": "skipped",
                "reason": "detect-secrets tool not installed",
            }
        except subprocess.TimeoutExpired:
            logger.error("Secret scan timed out")
            return {
                "status": "timeout",
                "reason": "Scan exceeded 60 second timeout",
            }
        except Exception as e:
            logger.error(f"Secret scan failed: {e}")
            return {
                "status": "error",
                "error": str(e),
            }

    def get_scan_report(self, scan_results: Dict[str, Any]) -> str:
        """
        Generate human-readable scan report.

        Args:
            scan_results: Results from run_security_scan()

        Returns:
            Formatted report string
        """
        report_lines = [
            "=" * 80,
            "SECURITY SCAN REPORT",
            "=" * 80,
            f"Timestamp: {scan_results['timestamp']}",
            f"Project Root: {scan_results['project_root']}",
            "",
            "SUMMARY",
            "-" * 80,
            f"Total Vulnerabilities: {scan_results['summary']['total_vulnerabilities']}",
            "",
        ]

        # Add scan details
        for scan_type, scan_data in scan_results["scans"].items():
            report_lines.extend(
                [
                    f"{scan_type.upper()} SCAN",
                    "-" * 80,
                    f"Status: {scan_data.get('status', 'unknown')}",
                ]
            )

            if scan_data.get("status") == "completed":
                count = scan_data.get("count", 0)
                report_lines.append(f"Findings: {count}")

                if "severity_breakdown" in scan_data:
                    report_lines.append("Severity Breakdown:")
                    for severity, count in scan_data["severity_breakdown"].items():
                        report_lines.append(f"  {severity}: {count}")

            elif scan_data.get("status") == "error":
                report_lines.append(f"Error: {scan_data.get('error', 'Unknown')}")

            report_lines.append("")

        report_lines.append("=" * 80)

        return "\n".join(report_lines)


# Convenience function
async def run_security_scan(
    scan_types: Optional[List[str]] = None,
    project_root: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Run security scan and return results.

    Args:
        scan_types: List of scan types to run
        project_root: Project root directory

    Returns:
        Scan results dictionary
    """
    scanner = SecurityScanner(project_root)
    return await scanner.run_security_scan(scan_types)

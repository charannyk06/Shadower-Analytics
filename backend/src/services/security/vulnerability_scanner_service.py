"""Vulnerability scanning service for security analytics."""

import logging
from typing import Dict, List, Any, Optional
from datetime import datetime
import uuid
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from ...models.schemas.security import (
    VulnerabilityScan,
    VulnerabilityScanResult,
    VulnerabilityDetails,
    VulnerabilitySummary,
    Severity,
)

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Scanner for detecting security vulnerabilities in agents."""

    def __init__(self, db: AsyncSession):
        """Initialize vulnerability scanner."""
        self.db = db

    async def scan_agent_vulnerabilities(
        self, agent_id: str, workspace_id: str, scan_type: str = "comprehensive"
    ) -> VulnerabilityScanResult:
        """
        Scan agent for security vulnerabilities.

        Args:
            agent_id: Agent identifier
            workspace_id: Workspace identifier
            scan_type: Type of scan (comprehensive, quick, targeted)

        Returns:
            VulnerabilityScanResult with found vulnerabilities
        """
        logger.info(f"Starting {scan_type} vulnerability scan for agent {agent_id}")

        scan_id = f"SCAN-{datetime.utcnow().strftime('%Y%m%d')}-{uuid.uuid4().hex[:8]}"
        started_at = datetime.utcnow()

        # Create scan record
        await self._create_scan_record(scan_id, agent_id, workspace_id, scan_type, started_at)

        try:
            # Run different vulnerability checks
            vulnerabilities = []

            if scan_type in ["comprehensive", "code"]:
                code_vulns = await self._scan_code_vulnerabilities(agent_id)
                vulnerabilities.extend(code_vulns)

            if scan_type in ["comprehensive", "dependencies"]:
                dep_vulns = await self._scan_dependencies(agent_id)
                vulnerabilities.extend(dep_vulns)

            if scan_type in ["comprehensive", "configuration"]:
                config_vulns = await self._scan_configurations(agent_id)
                vulnerabilities.extend(config_vulns)

            if scan_type in ["comprehensive", "targeted"]:
                api_vulns = await self._scan_api_endpoints(agent_id)
                vulnerabilities.extend(api_vulns)

                injection_vulns = await self._scan_injection_risks(agent_id)
                vulnerabilities.extend(injection_vulns)

            # Calculate summary
            summary = self._calculate_vulnerability_summary(vulnerabilities)

            # Calculate risk score
            risk_score = self._calculate_overall_risk(vulnerabilities)

            # Count exploitable vulnerabilities
            exploitable = sum(
                1 for v in vulnerabilities
                if v.exploitability in ["high", "confirmed"]
            )

            # Create remediation plan
            remediation_plan = self._create_remediation_plan(vulnerabilities)

            completed_at = datetime.utcnow()
            duration = int((completed_at - started_at).total_seconds())

            # Update scan record
            await self._update_scan_record(
                scan_id, summary, risk_score, exploitable, completed_at, duration, vulnerabilities, remediation_plan
            )

            # Create VulnerabilityScan object
            scan = VulnerabilityScan(
                scan_id=scan_id,
                agent_id=agent_id,
                workspace_id=workspace_id,
                scan_type=scan_type,
                status="completed",
                vulnerability_summary=summary,
                overall_risk_score=risk_score,
                exploitable_vulnerabilities=exploitable,
                started_at=started_at,
                completed_at=completed_at,
                duration_seconds=duration,
            )

            return VulnerabilityScanResult(
                scan=scan,
                vulnerabilities=vulnerabilities,
                remediation_plan=remediation_plan,
            )

        except Exception as e:
            logger.error(f"Vulnerability scan failed: {str(e)}", exc_info=True)
            await self._mark_scan_failed(scan_id)
            raise

    async def _create_scan_record(
        self, scan_id: str, agent_id: str, workspace_id: str, scan_type: str, started_at: datetime
    ):
        """Create initial scan record."""
        query = text("""
            INSERT INTO analytics.vulnerability_scans (
                scan_id, agent_id, workspace_id, scan_type, status, started_at
            ) VALUES (
                :scan_id, :agent_id, :workspace_id, :scan_type, 'running', :started_at
            )
        """)

        await self.db.execute(
            query,
            {
                "scan_id": scan_id,
                "agent_id": agent_id,
                "workspace_id": workspace_id,
                "scan_type": scan_type,
                "started_at": started_at,
            },
        )
        await self.db.commit()

    async def _update_scan_record(
        self,
        scan_id: str,
        summary: VulnerabilitySummary,
        risk_score: float,
        exploitable: int,
        completed_at: datetime,
        duration: int,
        vulnerabilities: List[VulnerabilityDetails],
        remediation_plan: Dict[str, Any],
    ):
        """Update scan record with results."""
        # Convert vulnerabilities to JSON
        vulns_json = [v.dict() for v in vulnerabilities]

        query = text("""
            UPDATE analytics.vulnerability_scans
            SET
                status = 'completed',
                critical_vulnerabilities = :critical,
                high_vulnerabilities = :high,
                medium_vulnerabilities = :medium,
                low_vulnerabilities = :low,
                info_vulnerabilities = :info,
                overall_risk_score = :risk_score,
                exploitable_vulnerabilities = :exploitable,
                completed_at = :completed_at,
                duration_seconds = :duration,
                vulnerabilities = :vulnerabilities::jsonb,
                remediation_plan = :remediation_plan::jsonb
            WHERE scan_id = :scan_id
        """)

        await self.db.execute(
            query,
            {
                "scan_id": scan_id,
                "critical": summary.critical,
                "high": summary.high,
                "medium": summary.medium,
                "low": summary.low,
                "info": summary.info,
                "risk_score": risk_score,
                "exploitable": exploitable,
                "completed_at": completed_at,
                "duration": duration,
                "vulnerabilities": str(vulns_json),
                "remediation_plan": str(remediation_plan),
            },
        )
        await self.db.commit()

    async def _mark_scan_failed(self, scan_id: str):
        """Mark scan as failed."""
        query = text("""
            UPDATE analytics.vulnerability_scans
            SET status = 'failed', completed_at = NOW()
            WHERE scan_id = :scan_id
        """)

        await self.db.execute(query, {"scan_id": scan_id})
        await self.db.commit()

    async def _scan_code_vulnerabilities(self, agent_id: str) -> List[VulnerabilityDetails]:
        """Scan code for security vulnerabilities."""
        vulnerabilities = []

        # Check for common code vulnerabilities
        # In a real implementation, this would use static analysis tools

        # Example: Check for hardcoded credentials
        vulnerabilities.append(
            VulnerabilityDetails(
                vulnerability_id=f"CODE-{uuid.uuid4().hex[:8]}",
                title="Potential Hardcoded Credentials",
                description="Code may contain hardcoded credentials or API keys",
                severity=Severity.HIGH,
                cvss_score=7.5,
                exploitability="medium",
                affected_component="agent_code",
                remediation="Use environment variables or secure vaults for credentials",
            )
        )

        return vulnerabilities

    async def _scan_dependencies(self, agent_id: str) -> List[VulnerabilityDetails]:
        """Scan dependencies for known vulnerabilities."""
        vulnerabilities = []

        # In a real implementation, this would check against vulnerability databases
        # like CVE, NVD, or use tools like Safety, Snyk, etc.

        return vulnerabilities

    async def _scan_configurations(self, agent_id: str) -> List[VulnerabilityDetails]:
        """Scan configurations for security issues."""
        vulnerabilities = []

        # Check for insecure configurations
        vulnerabilities.append(
            VulnerabilityDetails(
                vulnerability_id=f"CONFIG-{uuid.uuid4().hex[:8]}",
                title="Insecure Configuration Detected",
                description="Agent configuration may have insecure settings",
                severity=Severity.MEDIUM,
                cvss_score=5.3,
                exploitability="low",
                affected_component="agent_config",
                remediation="Review and harden agent configuration settings",
            )
        )

        return vulnerabilities

    async def _scan_api_endpoints(self, agent_id: str) -> List[VulnerabilityDetails]:
        """Scan API endpoints for vulnerabilities."""
        vulnerabilities = []

        # Check for API security issues
        # In a real implementation, this would test authentication, rate limiting, etc.

        return vulnerabilities

    async def _scan_injection_risks(self, agent_id: str) -> List[VulnerabilityDetails]:
        """Scan for injection vulnerabilities."""
        vulnerabilities = []

        # Check for SQL injection risks
        query = text("""
            SELECT COUNT(*) as injection_events
            FROM analytics.security_events
            WHERE agent_id = :agent_id
                AND event_type = 'injection'
                AND created_at > NOW() - INTERVAL '30 days'
        """)

        result = await self.db.execute(query, {"agent_id": agent_id})
        row = result.fetchone()

        if row and row.injection_events > 0:
            vulnerabilities.append(
                VulnerabilityDetails(
                    vulnerability_id=f"INJ-{uuid.uuid4().hex[:8]}",
                    title="Injection Vulnerability Detected",
                    description=f"Agent has {row.injection_events} injection attempts in the last 30 days",
                    severity=Severity.CRITICAL,
                    cvss_score=9.8,
                    exploitability="high",
                    affected_component="input_handling",
                    remediation="Implement input validation and use parameterized queries",
                )
            )

        # Check for prompt injection risks
        vulnerabilities.append(
            VulnerabilityDetails(
                vulnerability_id=f"PROMPT-{uuid.uuid4().hex[:8]}",
                title="Potential Prompt Injection Risk",
                description="Agent may be vulnerable to prompt injection attacks",
                severity=Severity.HIGH,
                cvss_score=7.5,
                exploitability="medium",
                affected_component="prompt_processing",
                remediation="Implement prompt sanitization and validation",
            )
        )

        return vulnerabilities

    def _calculate_vulnerability_summary(
        self, vulnerabilities: List[VulnerabilityDetails]
    ) -> VulnerabilitySummary:
        """Calculate vulnerability summary by severity."""
        summary = VulnerabilitySummary()

        for vuln in vulnerabilities:
            if vuln.severity == Severity.CRITICAL:
                summary.critical += 1
            elif vuln.severity == Severity.HIGH:
                summary.high += 1
            elif vuln.severity == Severity.MEDIUM:
                summary.medium += 1
            elif vuln.severity == Severity.LOW:
                summary.low += 1
            else:
                summary.info += 1

        return summary

    def _calculate_overall_risk(self, vulnerabilities: List[VulnerabilityDetails]) -> float:
        """Calculate overall risk score."""
        if not vulnerabilities:
            return 0.0

        # Weight by severity
        weights = {
            Severity.CRITICAL: 10,
            Severity.HIGH: 7,
            Severity.MEDIUM: 4,
            Severity.LOW: 2,
            Severity.INFO: 1,
        }

        total_weight = sum(weights.get(v.severity, 1) for v in vulnerabilities)
        max_possible = len(vulnerabilities) * 10

        return min((total_weight / max_possible) * 100 if max_possible > 0 else 0.0, 100.0)

    def _create_remediation_plan(
        self, vulnerabilities: List[VulnerabilityDetails]
    ) -> Dict[str, Any]:
        """Create remediation plan for found vulnerabilities."""
        # Group by severity
        critical = [v for v in vulnerabilities if v.severity == Severity.CRITICAL]
        high = [v for v in vulnerabilities if v.severity == Severity.HIGH]
        medium = [v for v in vulnerabilities if v.severity == Severity.MEDIUM]

        plan = {
            "immediate_actions": [v.remediation for v in critical if v.remediation],
            "short_term_actions": [v.remediation for v in high if v.remediation],
            "long_term_actions": [v.remediation for v in medium if v.remediation],
            "estimated_fix_time_hours": self._estimate_fix_time(vulnerabilities),
            "priority_order": [
                {"vulnerability_id": v.vulnerability_id, "title": v.title, "severity": v.severity.value}
                for v in sorted(vulnerabilities, key=lambda x: (
                    ["info", "low", "medium", "high", "critical"].index(x.severity.value)
                ), reverse=True)
            ],
        }

        return plan

    def _estimate_fix_time(self, vulnerabilities: List[VulnerabilityDetails]) -> int:
        """Estimate time to fix all vulnerabilities."""
        # Rough estimates by severity
        time_estimates = {
            Severity.CRITICAL: 8,  # hours
            Severity.HIGH: 4,
            Severity.MEDIUM: 2,
            Severity.LOW: 1,
            Severity.INFO: 0.5,
        }

        total_hours = sum(time_estimates.get(v.severity, 1) for v in vulnerabilities)
        return int(total_hours)
